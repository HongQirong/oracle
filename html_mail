DECLARE
    MESSAGE   VARCHAR2 (1000);
BEGIN
    MESSAGE :=
           '<TABLE  border = 2>'
        || '<TR style ="background-color :Red">'
        || '<TD>'
        || '你好1'
        || '</TD>'
        || '<TD>'
        || '你好2'
        || '</TD>'
        || '</TR>';
    MESSAGE :=
           MESSAGE
        || '<TR>'
        || '<TD>'
        || '你好3'
        || '</TD>'
        || '<TD align=right>'
        || '你好4'
        || '</TD>'
        || '<TD align=right>'
        || '你好5'
        || '</TD>'
        || '</TR>';
    MESSAGE := MESSAGE || '</TABLE>';
END;

CREATE OR REPLACE PACKAGE apps.xx
IS
   TYPE alert_rec IS RECORD
   (
      batch_id NUMBER
     ,sort_order NUMBER
     ,rec1 VARCHAR2(2000)
     ,rec2 VARCHAR2(2000)
     ,rec3 VARCHAR2(2000)
     ,rec4 VARCHAR2(2000)
     ,rec5 VARCHAR2(2000)
     ,rec6 VARCHAR2(2000)
     ,rec7 VARCHAR2(2000)
     ,rec8 VARCHAR2(2000)
     ,rec9 VARCHAR2(2000)
     ,rec10 VARCHAR2(2000)
     ,rec11 VARCHAR2(2000)
     ,rec12 VARCHAR2(2000)
     ,rec13 VARCHAR2(2000)
     ,rec14 VARCHAR2(2000)
     ,rec15 VARCHAR2(2000)
     ,rec16 VARCHAR2(2000)
     ,rec17 VARCHAR2(2000)
     ,rec18 VARCHAR2(2000)
     ,rec19 VARCHAR2(2000)
     ,rec20 VARCHAR2(2000)
     ,rec21 VARCHAR2(2000)
     ,rec22 VARCHAR2(2000)
     ,rec23 VARCHAR2(2000)
     ,rec24 VARCHAR2(2000)
     ,rec25 VARCHAR2(2000)
     ,rec26 VARCHAR2(2000)
     ,rec27 VARCHAR2(2000)
     ,rec28 VARCHAR2(2000)
     ,rec29 VARCHAR2(2000)
     ,rec30 VARCHAR2(2000)
     ,rec31 VARCHAR2(2000)
     ,rec32 VARCHAR2(2000)
     ,rec33 VARCHAR2(2000)
     ,rec34 VARCHAR2(2000)
     ,rec35 VARCHAR2(2000)
     ,rec36 VARCHAR2(2000)
     ,rec37 VARCHAR2(2000)
     ,rec38 VARCHAR2(2000)
     ,rec39 VARCHAR2(2000)
     ,rec40 VARCHAR2(2000)
     ,rec41 VARCHAR2(2000)
     ,rec42 VARCHAR2(2000)
     ,rec43 VARCHAR2(2000)
     ,rec44 VARCHAR2(2000)
     ,rec45 VARCHAR2(2000)
     ,rec46 VARCHAR2(2000)
     ,rec47 VARCHAR2(2000)
     ,rec48 VARCHAR2(2000)
     ,rec49 VARCHAR2(2000)
     ,rec50 VARCHAR2(2000)
   );

   TYPE xx_cursor IS REF CURSOR;

   batch_null EXCEPTION;

   v_conn UTL_SMTP.connection;
   v_smtp_host VARCHAR2(50) := '10.16.1.140';
   v_crlf VARCHAR2(2)
      := CHR(13)
         || CHR(10);
   v_smtp_port NUMBER := 25;
   v_attach_path VARCHAR2(200) := 'DIR_FOR_SEND_MAIL1';
   v_attach_name VARCHAR2(200);
   v_filehandle UTL_FILE.file_type;
   v_sql VARCHAR2(32767);
   v_line VARCHAR2(100);
   v_db VARCHAR2(200) := apps.fnd_profile.VALUE('APPS_DATABASE_ID');

   v_html CLOB;
   v_header CLOB;
   v_temp_count NUMBER;
   v_batch_id NUMBER;
   v_column NUMBER;
   v_delete_sql VARCHAR2(200) := 'DELETE XX_ALERT_TEMP WHERE BATCH_ID = ';
   v_delete_history VARCHAR2(200) := 'DELETE XX_ALERT_TEMP WHERE BATCH_ID < ';
   v_count_history VARCHAR2(200) := 'SELECT COUNT(*) FROM XX_ALERT_TEMP WHERE BATCH_ID <';
   v_count_his NUMBER;
   v_html_rec NUMBER;
   v_count_sql VARCHAR2(200) := 'SELECT COUNT(*) FROM XX_ALERT_TEMP WHERE BATCH_ID =';
   v_init_count NUMBER;
   v_dymanic_sql VARCHAR2(20000);
   v_dymanic_column VARCHAR2(20000);

   v_insert_sql VARCHAR2(20000) := 'INSERT INTO XX_ALERT_TEMP(BATCH_ID,SORT_ORDER,';

   chk_box VARCHAR2(200) := '<CENTER><INPUT TYPE="CHECKBOX" ';



   PROCEDURE init_data_new(p_batch_id     NUMBER
                          ,p_data         xx_cursor
                          ,p_colcnt   OUT NUMBER
                          ,p_msg      OUT VARCHAR2);



   PROCEDURE column_count(p_sql       VARCHAR2
                         ,p_count OUT NUMBER
                         ,p_msg   OUT VARCHAR2);


   PROCEDURE create_tempdata(p_batch_id IN     NUMBER
                            ,p_sql      IN     VARCHAR2
                            ,p_count       OUT NUMBER
                            ,p_msg         OUT VARCHAR2);



   PROCEDURE send_alert(p_subject         VARCHAR2
                       ,p_rec_list        VARCHAR2
                       ,p_cc              VARCHAR2
                       ,p_html_flag       VARCHAR2 DEFAULT 'Y'
                       ,p_html_rec        NUMBER DEFAULT 50
                       ,p_excel_flag      VARCHAR2 DEFAULT 'Y'
                       ,p_delete_flag     VARCHAR2 DEFAULT 'Y'
                       ,p_data            xx_cursor
                       ,p_send_nodata     NUMBER
                       ,p_batch_id    OUT NUMBER
                       ,p_msg         OUT VARCHAR2);

   FUNCTION check_sql(p_temp  NUMBER)
      RETURN VARCHAR2;

   FUNCTION return_process_name
      RETURN VARCHAR2;
END xx;
CREATE OR REPLACE PACKAGE BODY apps.xx
IS
   PROCEDURE init_data_new(p_batch_id     NUMBER
                          ,p_data         xx_cursor
                          ,p_colcnt   OUT NUMBER
                          ,p_msg      OUT VARCHAR2)
   IS
      v_rc xx_cursor;
      v_c NUMBER;
      v_colcnt NUMBER;
      v_desc_tab DBMS_SQL.desc_tab;
      v_sql VARCHAR2(3000);
      l_insert_sql VARCHAR2(1000);
      v_column_name VARCHAR2(3000);
      v_column_value VARCHAR2(2000);
      l_value VARCHAR2(200);
      v_name VARCHAR2(200);
      v_num NUMBER;
      v_date DATE;
      v_count NUMBER := 0;
   BEGIN
      v_rc := p_data;
      v_c := DBMS_SQL.to_cursor_number(v_rc);

      DBMS_SQL.describe_columns(v_c
                               ,v_colcnt
                               ,v_desc_tab);
      p_colcnt := v_colcnt;

      -- insert xx_alert_temp表頭 start--------------------------------------------------------
      FOR i IN 1 .. v_colcnt
      LOOP
         v_sql := v_sql
                  || 'temp'
                  || i
                  || ',';
         DBMS_OUTPUT.put_line(v_desc_tab(i).col_name);
         v_column_name := v_column_name
                          || ''''
                          || v_desc_tab(i).col_name
                          || ''''
                          || ',';
      END LOOP;

      v_column_name := SUBSTR(v_column_name
                             ,1
                             ,  LENGTH(v_column_name)
                              - 1);
      v_sql := SUBSTR(v_sql
                     ,1
                     ,  LENGTHB(v_sql)
                      - 1)
               || ')';
      l_insert_sql := v_insert_sql
                      || v_sql
                      || 'values'
                      || '('
                      || p_batch_id
                      || ',';
      v_sql := v_insert_sql
               || v_sql
               || 'values'
               || '('
               || p_batch_id
               || ','
               || '0,'
               || v_column_name
               || ')';

      DBMS_OUTPUT.enable(10000000);

      --DBMS_OUTPUT.PUT_LINE(v_sql);

      BEGIN
         EXECUTE IMMEDIATE v_sql; --insert 表頭
      EXCEPTION
         WHEN OTHERS
         THEN
            p_msg := 'PROCEDURE=>init_data_new error，'
                     || 'insert表頭錯誤：'
                     || SQLERRM;
            RAISE batch_null;
      END;

      -- insert xx_alert_temp表頭 end--------------------------------------------------------


      -- insert xx_alert_temp明細 start--------------------------------------------------------
      FOR i IN 1 .. v_colcnt
      LOOP
         --此處是定義游標中列的讀取類型，可以定義為字符，數字和日期類型
         IF v_desc_tab(i).col_type = 2
         THEN
            DBMS_SQL.define_column(v_c
                                  ,i
                                  ,v_num);
         ELSIF v_desc_tab(i).col_type = 12
         THEN
            DBMS_SQL.define_column(v_c
                                  ,i
                                  ,v_date);
         ELSE
            DBMS_SQL.define_column(v_c
                                  ,i
                                  ,v_name
                                  ,200);
         END IF;
      END LOOP;

      -- DBMS_SQL包獲取行
      --從游標中把數據檢索到緩存區（BUFFER）中，緩衝區 的值只能被函數COULUMN_VALUE()所讀取
      WHILE DBMS_SQL.fetch_rows(v_c) > 0
      LOOP
         v_column_value := '';

         --函數column_value()把緩衝區的列的值讀入相應變量中。
         FOR i IN 1 .. v_colcnt
         LOOP
            l_value := '';

            IF (v_desc_tab(i).col_type = 1)
            THEN
               DBMS_SQL.COLUMN_VALUE(v_c
                                    ,i
                                    ,v_name);
               l_value := v_name;
               DBMS_OUTPUT.put_line(v_name);
            ELSIF (v_desc_tab(i).col_type = 2)
            THEN
               DBMS_SQL.COLUMN_VALUE(v_c
                                    ,i
                                    ,v_num);
               l_value := TO_CHAR(v_num);
               DBMS_OUTPUT.put_line(v_num);
            ELSIF (v_desc_tab(i).col_type = 12)
            THEN
               DBMS_SQL.COLUMN_VALUE(v_c
                                    ,i
                                    ,v_date);
               l_value := TO_CHAR(v_date
                                 ,'YYYY-MM-DD HH24:MI:SS');
               DBMS_OUTPUT.put_line(TO_CHAR(v_date
                                           ,'YYYY-MM-DD HH24:MI:SS'));
            ELSE
               DBMS_SQL.COLUMN_VALUE(v_c
                                    ,i
                                    ,v_name);
               l_value := v_name;
               DBMS_OUTPUT.put_line(v_name);
            END IF;

            IF i < v_colcnt
            THEN
               v_column_value := v_column_value
                                 || ''''
                                 || l_value
                                 || ''''
                                 || ',';
            ELSE
               v_column_value := v_column_value
                                 || ''''
                                 || l_value
                                 || ''''
                                 || ')';
            END IF;
         END LOOP;

         v_count :=   v_count
                    + 1;

         DBMS_OUTPUT.put_line(l_insert_sql
                              || v_count
                              || ','
                              || v_column_value);

         BEGIN
            EXECUTE IMMEDIATE
               l_insert_sql
               || v_count
               || ','
               || v_column_value; --insert欄位資料
         EXCEPTION
            WHEN OTHERS
            THEN
               p_msg := 'PROCEDURE=>init_data_new error ：'
                        || 'insert欄位資料錯誤:'
                        || SQLERRM;
               RAISE batch_null;
         END;
      END LOOP;

      DBMS_SQL.close_cursor(v_c);
      --close p_data;

      -- insert xx_alert_temp明細 start--------------------------------------------------------

      COMMIT;
   EXCEPTION
      WHEN batch_null
      THEN
         DBMS_OUTPUT.put_line(p_msg);
      WHEN OTHERS
      THEN
         p_msg := 'PROCEDURE=>init_data_new error：'
                  || SQLERRM;
         DBMS_OUTPUT.put_line(p_msg);
   END init_data_new;



   FUNCTION check_sql(p_temp  NUMBER) --檢查XX_ALERT_TEMP
      RETURN VARCHAR2
   IS
      v_flag xx_alert_temp.temp1%TYPE;
      v_chk_sql VARCHAR2(2000);
      v_temp_str VARCHAR2(10)
         := 'temp'
            || TO_CHAR(p_temp);
   BEGIN
      v_chk_sql := 'select distinct '
                   || v_temp_str
                   || ' from xx_alert_temp'
                   || ' where batch_id ='
                   || v_batch_id
                   || ' and '
                   || v_temp_str
                   || ' is not null '
                   || ' and sort_order != 1';

      EXECUTE IMMEDIATE v_chk_sql INTO v_flag;

      RETURN (v_flag);
   EXCEPTION
      WHEN OTHERS
      THEN
         v_flag := 'N';
         RETURN (v_flag);
   END check_sql;


   PROCEDURE column_count(p_sql       VARCHAR2
                         ,p_count OUT NUMBER
                         ,p_msg   OUT VARCHAR2)
   IS
      v_sql VARCHAR2(20000);
   BEGIN
      p_msg := NULL;
      v_sql := UPPER(TO_CHAR(p_sql));

      DBMS_OUTPUT.put_line('V_SQL='
                           || v_sql);

      --DBMS_OUTPUT.PUT_LINE('HERE1');
      BEGIN
         SELECT SUBSTR(v_sql
                      ,8
                      ,  INSTR(v_sql
                              ,'FROM')
                       - 9)
           INTO v_sql
           FROM DUAL;
      EXCEPTION
         WHEN OTHERS
         THEN
            p_msg := 'PROCEDURE=>COLUMN_COUNT ERROR ：'
                     || SQLERRM;
            RAISE batch_null;
      END;

      --DBMS_OUTPUT.PUT_LINE('HERE2');
      DBMS_OUTPUT.put_line('V_SQL='
                           || v_sql);

      /*if v_sql like '%*%' or v_sql like '%.*%' then
         p_msg:='PROCEDURE=>column_count error ：'||'傳入之sql不可以有select *';
         RAISE batch_null;
      end if;*/

      --DBMS_OUTPUT.put_line('here3');
      BEGIN
         SELECT CASE
                   WHEN (  LENGTHB(v_sql)
                         - LENGTHB(REPLACE(v_sql
                                          ,','
                                          ,''))) = 0
                   THEN
                      0
                   ELSE
                        (  LENGTHB(v_sql)
                         - LENGTHB(REPLACE(v_sql
                                          ,','
                                          ,'')))
                      + 1
                END
           INTO p_count
           FROM DUAL;
      EXCEPTION
         WHEN OTHERS
         THEN
            p_msg := 'PROCEDURE=>column_count error ：'
                     || SQLERRM;
            RAISE batch_null;
      END;

      --DBMS_OUTPUT.put_line('here4');
      IF NVL(p_count, 0) <= 0
      THEN
         p_msg := 'PROCEDURE=>column_count error ：'
                  || 'select字樣之後須有欄位 !!';
         RAISE batch_null;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_msg := NVL(p_msg, 'PROCEDURE=>COLUMN_COUNT ERROR !!');
   END column_count;


   PROCEDURE create_tempdata(p_batch_id IN     NUMBER
                            ,p_sql      IN     VARCHAR2
                            ,p_count       OUT NUMBER
                            ,p_msg         OUT VARCHAR2)
   IS
      v_sql VARCHAR2(20000);
      --V_COUNT                                NUMBER;
      --V_COUNT2                               NUMBER;
      --V_MSG            VARCHAR2(2000);
      v_select VARCHAR2(20000);
      v_sql_upd VARCHAR2(20000);
      v_insert_sql VARCHAR2(20000) := 'INSERT INTO XX_ALERT_TEMP(BATCH_ID,SORT_ORDER,';
      v_insert_header_sql VARCHAR2(20000);
      v_workstr VARCHAR2(20000);
      v_column_name VARCHAR2(20000);
   BEGIN
      column_count(p_sql
                  ,p_count
                  ,p_msg);

      IF p_msg IS NOT NULL
      THEN
         RAISE batch_null;
      END IF;

      --DBMS_OUTPUT.put_line('HERE 5');
      IF p_count > 50
      THEN
         p_msg := 'PROCEDURE=>create_tempdata error ：'
                  || '欄位不可超過50個';
         RAISE batch_null;
      END IF;

      --DBMS_OUTPUT.put_line('HERE 6');


      v_select := 'SELECT '
                  || p_batch_id
                  || ',rownum,';

      v_sql_upd := REPLACE(UPPER(p_sql)
                          ,'SELECT '
                          ,v_select);

      v_sql := v_insert_sql;

      FOR i IN 1 .. p_count
      LOOP
         v_sql := v_sql
                  || 'temp'
                  || i
                  || ',';
         v_workstr := REPLACE(UPPER(p_sql)
                             ,','
                             ,', ');

         IF i = p_count
         THEN
            v_workstr := SUBSTR(v_workstr
                               ,1
                               ,  INSTR(v_workstr
                                       ,'FROM'
                                       ,1
                                       ,1)
                                - 1);
            v_workstr := RTRIM(v_workstr
                              ,' ');
            v_column_name := v_column_name
                             || ''''
                             || SUBSTR(v_workstr
                                      ,  INSTR(v_workstr
                                              ,' '
                                              ,-1)
                                       + 1)
                             || '''';
         ELSE
            v_workstr := SUBSTR(v_workstr
                               ,1
                               ,  INSTR(v_workstr
                                       ,','
                                       ,1
                                       ,i)
                                - 1);
            v_workstr := RTRIM(v_workstr
                              ,' ');
            v_column_name := v_column_name
                             || ''''
                             || SUBSTR(v_workstr
                                      ,  INSTR(v_workstr
                                              ,' '
                                              ,-1)
                                       + 1)
                             || ''''
                             || ',';
         END IF;
      END LOOP;

      v_sql := SUBSTR(v_sql
                     ,1
                     ,  LENGTHB(v_sql)
                      - 1)
               || ')';

      v_insert_header_sql := v_sql
                             || 'values'
                             || '('
                             || p_batch_id
                             || ','
                             || '0,'
                             || v_column_name
                             || ')';

      --dbms_output.put_line(v_insert_header_sql);

      v_sql := v_sql
               || ' '
               || v_sql_upd;

      --dbms_output.put_line(v_sql);

      BEGIN
         EXECUTE IMMEDIATE v_insert_header_sql;
      EXCEPTION
         WHEN OTHERS
         THEN
            p_msg := 'Err:'
                     || SQLERRM;
      --DBMS_OUTPUT.put_line(p_msg);
      END;

      BEGIN
         EXECUTE IMMEDIATE v_sql;
      EXCEPTION
         WHEN OTHERS
         THEN
            p_msg := 'Err:'
                     || SQLERRM;
      --DBMS_OUTPUT.put_line(p_msg);



      END;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_msg := NVL(p_msg, 'PROCEDURE=>CREATE_TEMPDATA ERROR !!');
   END create_tempdata;


   PROCEDURE send_alert(p_subject         VARCHAR2
                       , --主題
                        p_rec_list        VARCHAR2
                       , --收件者
                        p_cc              VARCHAR2
                       , --CC的人
                        p_html_flag       VARCHAR2 DEFAULT 'Y'
                       , --是否產生HTML
                        p_html_rec        NUMBER DEFAULT 50
                       , --HTML最多列印筆數
                        p_excel_flag      VARCHAR2 DEFAULT 'Y'
                       , --是否產生EXCEL檔
                        p_delete_flag     VARCHAR2 DEFAULT 'Y'
                       , --是否系統發出信件後刪除資料
                        p_data            xx_cursor
                       , --傳入CURSOR
                        p_send_nodata     NUMBER
                       , -- 0-代表沒有資料就不發送 1-代表沒有資料仍要發送
                        p_batch_id    OUT NUMBER
                       , --BATCH_ID
                        p_msg         OUT VARCHAR2 --錯誤訊息
                                                  )
   IS
      x xx_cursor;
      z alert_rec;
      v_count NUMBER;
      v_loc NUMBER;
      v_note VARCHAR2(200);
      v_prog VARCHAR2(300);
      v_str VARCHAR2(4000);

      v_strowner VARCHAR2(32767);
      --V_STRNAME        VARCHAR2(32767);
      v_nlineno NUMBER;
      v_strcaller_t VARCHAR2(32767);
      v_request_id NUMBER;
      v_concurrent_program_name VARCHAR2(50);
      v_execution_file_name VARCHAR2(80);
   BEGIN
      OWA_UTIL.who_called_me(v_strowner
                            ,v_prog
                            ,v_nlineno
                            ,v_strcaller_t);

      p_batch_id := xx_alert_temp_seq.NEXTVAL;

      v_request_id := apps.fnd_global.conc_request_id;

      IF v_request_id IS NOT NULL
      THEN
         BEGIN
            SELECT '並行程式：'
                   || NVL(fcp.concurrent_program_name, '*')
                  ,'執行檔：'
                   || NVL(e.execution_file_name, '*')
              INTO v_concurrent_program_name
                  ,v_execution_file_name
              FROM fnd_concurrent_requests fcr
                  ,fnd_concurrent_programs fcp
                   LEFT OUTER JOIN fnd_executables e
                      ON fcp.executable_id = e.executable_id
                         AND fcp.application_id = e.application_id
             WHERE 1 = 1
                   AND fcr.concurrent_program_id = fcp.concurrent_program_id
                   AND fcr.program_application_id = fcp.application_id
                   AND fcr.request_id = v_request_id;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               v_concurrent_program_name := NULL;
               v_execution_file_name := NULL;
            WHEN OTHERS
            THEN
               p_msg := 'PROCEDURE=>send_alert error：SELECT V_CONCURRENT_PROGRAM_NAME =>'
                        || SQLERRM;
               RAISE batch_null;
         END;

         IF v_execution_file_name IS NOT NULL
         THEN
            v_prog := v_execution_file_name;
         ELSE
            IF v_concurrent_program_name IS NOT NULL
            THEN
               v_prog := v_execution_file_name;
            ELSE
               v_prog := '程式：'
                         || NVL(v_prog, '*');
            END IF;
         END IF;
      END IF;

      --create_tempdata(p_batch_id,p_sql,v_column,p_msg);

      init_data_new(p_batch_id
                   ,p_data
                   ,v_column
                   ,p_msg);

      IF p_msg IS NOT NULL
      THEN
         RAISE batch_null;
      END IF;

      BEGIN
         EXECUTE IMMEDIATE
            v_count_sql
            || p_batch_id
            INTO v_temp_count;
      EXCEPTION
         WHEN OTHERS
         THEN
            p_msg := 'PROCEDURE=>SEND_ALERT ERROR ：'
                     || '計算筆數錯誤:'
                     || SQLERRM;
            RAISE batch_null;
      END;


      IF v_temp_count < 0
      THEN
         p_msg := 'PROCEDURE=>SEND_ALERT：無資料';
         RETURN;
      --RAISE BATCH_NULL;
      END IF;

      --判斷CURSOR無資料不發送MAIL
      IF NVL(v_temp_count, 1) = 1
         AND NVL(p_send_nodata, 0) = 0
      THEN
         GOTO the_end;
      END IF;

      v_html_rec := CASE WHEN p_html_rec > 50 THEN 50 ELSE p_html_rec END;

      v_conn := UTL_SMTP.open_connection(v_smtp_host
                                        ,v_smtp_port); --開啟 Mail Connection 物件
      UTL_SMTP.helo(v_conn
                   ,v_smtp_host); --設定MAIL PORT
      UTL_SMTP.mail(v_conn
                   ,'');

      --UTL_SMTP.rcpt (v_conn,'<'||p_rec_list||'>');
      SELECT DECODE(INSTR(p_rec_list
                         ,';')
                   ,0, INSTR(p_rec_list
                            ,',')
                   ,INSTR(p_rec_list
                         ,';'))
        INTO v_loc
        FROM DUAL; --取得逗號或分號的位置

      IF v_loc = 0
      THEN -- 當收件者多位時需要LOOP 一個一個指定,故給第一位收件者,最後讓xxsend_mail 拆分發送給各收件者
         UTL_SMTP.rcpt(v_conn
                      ,'<'
                       || SUBSTR(p_rec_list
                                ,1)
                       || '>');
      ELSE
         UTL_SMTP.rcpt(v_conn
                      ,'<'
                       || SUBSTR(p_rec_list
                                ,1
                                ,  v_loc
                                 - 1)
                       || '>');
      END IF;

      UTL_SMTP.open_data(v_conn); --設定 發信內容
      UTL_SMTP.write_data(v_conn
                         ,'Content-Type: text/html; charset="utf-8"'
                          || UTL_TCP.crlf); -- 寫入 Mail Header

      IF NVL(p_html_flag, 'Y') = 'Y'
      THEN --如果html_flag 等於Y 且 v_temp_count大於v_html_rec 則Mail內容顯示資料超過多少筆 請詳附檔
         IF v_temp_count > v_html_rec
         THEN
            v_note := ' 3.資料超過'
                      || v_html_rec
                      || '筆請詳excel附檔 !!<br>';
         ELSE
            v_note := '';
         END IF;

         UTL_SMTP.write_data(v_conn
                            ,'<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; ">'
                             || UTL_TCP.crlf
                             || '<content="MSHTML 6.00.2800.1276" name=GENERATOR>'
                             || UTL_TCP.crlf
                             || '<HTML><BODY>');

         v_html := '<div style="font-family:Microsoft JhengHei;font-size:x-small;"> ' --寫入表頭
                   || '1.本郵件為系統送出,勿直接回信 !!<br>'
                   || '2.有問題請聯絡資訊部負責人 !!<br> '
                   || v_note
                   || UTL_TCP.crlf
                   || '<center><h4><font color=#000099>'
                   || p_subject
                   || '</font></h4></center>';

         UTL_SMTP.write_raw_data(v_conn
                                ,UTL_RAW.cast_to_raw(CONVERT(v_html
                                                            ,'ZHT16MSWIN950')));
         v_html := v_html
                   || '<TABLE style="font-size:x-small;border:3px #FFAC55 double;padding:1px;" rules="all" cellpadding="1"> <div style="font-family:Microsoft JhengHei;font-size:x-small;">';
         v_html := v_html
                   || '<tr BGCOLOR=gray>';


         --v_sql := 'select * from xx_alert_temp'
         v_sql := 'select batch_id,sort_order,temp1,temp2,temp3,temp4,temp5,temp6,temp7,temp8,temp9,temp10,
                                                temp11,temp12,temp13,temp14,temp15,temp16,temp17,temp18,temp19,temp20,
                                                temp21,temp22,temp23,temp24,temp25,temp26,temp27,temp28,temp29,temp30,
                                                temp31,temp32,temp33,temp34,temp35,temp36,temp37,temp38,temp39,temp40,
                                                temp41,temp42,temp43,temp44,temp45,temp46,temp47,temp48,temp49,temp50
                   from xx_alert_temp'
                  || ' where batch_id ='
                  || p_batch_id
                  || ' order by sort_order';


         OPEN x FOR v_sql;

         LOOP
            FETCH x INTO z;

            EXIT WHEN x%NOTFOUND;

            IF z.sort_order = 0
            THEN --寫入欄位表頭
               v_html := v_html
                         || '<th><b><font color=white>No.</font></th>';

               FOR k IN 1 .. v_column
               LOOP
                  v_html := v_html
                            || '<th><b><font color=white>'
                            || CASE
                                  WHEN k = 1 THEN z.rec1
                                  WHEN k = 2 THEN z.rec2
                                  WHEN k = 3 THEN z.rec3
                                  WHEN k = 4 THEN z.rec4
                                  WHEN k = 5 THEN z.rec5
                                  WHEN k = 6 THEN z.rec6
                                  WHEN k = 7 THEN z.rec7
                                  WHEN k = 8 THEN z.rec8
                                  WHEN k = 9 THEN z.rec9
                                  WHEN k = 10 THEN z.rec10
                                  WHEN k = 11 THEN z.rec11
                                  WHEN k = 12 THEN z.rec12
                                  WHEN k = 13 THEN z.rec13
                                  WHEN k = 14 THEN z.rec14
                                  WHEN k = 15 THEN z.rec15
                                  WHEN k = 16 THEN z.rec16
                                  WHEN k = 17 THEN z.rec17
                                  WHEN k = 18 THEN z.rec18
                                  WHEN k = 19 THEN z.rec19
                                  WHEN k = 20 THEN z.rec20
                                  WHEN k = 21 THEN z.rec21
                                  WHEN k = 22 THEN z.rec22
                                  WHEN k = 23 THEN z.rec23
                                  WHEN k = 24 THEN z.rec24
                                  WHEN k = 25 THEN z.rec25
                                  WHEN k = 26 THEN z.rec26
                                  WHEN k = 27 THEN z.rec27
                                  WHEN k = 28 THEN z.rec28
                                  WHEN k = 29 THEN z.rec29
                                  WHEN k = 30 THEN z.rec30
                                  WHEN k = 31 THEN z.rec31
                                  WHEN k = 32 THEN z.rec32
                                  WHEN k = 33 THEN z.rec33
                                  WHEN k = 34 THEN z.rec34
                                  WHEN k = 35 THEN z.rec35
                                  WHEN k = 36 THEN z.rec36
                                  WHEN k = 37 THEN z.rec37
                                  WHEN k = 38 THEN z.rec38
                                  WHEN k = 39 THEN z.rec39
                                  WHEN k = 40 THEN z.rec40
                                  WHEN k = 41 THEN z.rec41
                                  WHEN k = 42 THEN z.rec42
                                  WHEN k = 43 THEN z.rec43
                                  WHEN k = 44 THEN z.rec44
                                  WHEN k = 45 THEN z.rec45
                                  WHEN k = 46 THEN z.rec46
                                  WHEN k = 47 THEN z.rec47
                                  WHEN k = 48 THEN z.rec48
                                  WHEN k = 49 THEN z.rec49
                                  WHEN k = 50 THEN z.rec50
                               END
                            || '</font></th>';
               END LOOP;
            ELSE
               v_html := v_html
                         || HTF.tablerowopen; --寫入明細
               v_count :=   NVL(v_count, 0)
                          + 1;
               v_html := v_html
                         || HTF.tabledata(CASE
                                             WHEN MOD(v_count
                                                     ,5) = 0
                                             THEN
                                                '<tr BGCOLOR=#A3A3FF>'
                                          END --每5筆設定背景顏色為#A3A3FF
                                          || HTF.escape_sc(v_count));


               FOR j IN 1 .. v_column
               LOOP
                  v_html := v_html
                            || HTF.tabledata(
                                  CASE
                                     WHEN check_sql(j) = 'V'
                                     THEN
                                        chk_box
                                        || CASE
                                              WHEN z.rec1 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec2 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec3 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec4 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec5 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec6 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec7 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec8 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec9 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec10 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec11 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec12 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec13 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec14 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec15 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec16 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec17 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec18 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec19 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec20 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec21 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec22 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec23 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec24 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec25 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec26 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec27 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec28 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec29 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec30 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec31 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec32 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec33 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec34 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec35 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec36 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec37 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec38 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec39 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec40 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec41 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec42 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec43 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec44 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec45 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec46 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec47 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec48 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec49 = 'V' THEN 'CHECKED>'
                                              WHEN z.rec50 = 'V' THEN 'CHECKED>'
                                              ELSE 'UNCHCKED>'
                                           END
                                     ELSE
                                        HTF.escape_sc(
                                           CASE
                                              WHEN j = 1 THEN z.rec1
                                              WHEN j = 2 THEN z.rec2
                                              WHEN j = 3 THEN z.rec3
                                              WHEN j = 4 THEN z.rec4
                                              WHEN j = 5 THEN z.rec5
                                              WHEN j = 6 THEN z.rec6
                                              WHEN j = 7 THEN z.rec7
                                              WHEN j = 8 THEN z.rec8
                                              WHEN j = 9 THEN z.rec9
                                              WHEN j = 10 THEN z.rec10
                                              WHEN j = 11 THEN z.rec11
                                              WHEN j = 12 THEN z.rec12
                                              WHEN j = 13 THEN z.rec13
                                              WHEN j = 14 THEN z.rec14
                                              WHEN j = 15 THEN z.rec15
                                              WHEN j = 16 THEN z.rec16
                                              WHEN j = 17 THEN z.rec17
                                              WHEN j = 18 THEN z.rec18
                                              WHEN j = 19 THEN z.rec19
                                              WHEN j = 20 THEN z.rec20
                                              WHEN j = 21 THEN z.rec21
                                              WHEN j = 22 THEN z.rec22
                                              WHEN j = 23 THEN z.rec23
                                              WHEN j = 24 THEN z.rec24
                                              WHEN j = 25 THEN z.rec25
                                              WHEN j = 26 THEN z.rec26
                                              WHEN j = 27 THEN z.rec27
                                              WHEN j = 28 THEN z.rec28
                                              WHEN j = 29 THEN z.rec29
                                              WHEN j = 30 THEN z.rec30
                                              WHEN j = 31 THEN z.rec31
                                              WHEN j = 32 THEN z.rec32
                                              WHEN j = 33 THEN z.rec33
                                              WHEN j = 34 THEN z.rec34
                                              WHEN j = 35 THEN z.rec35
                                              WHEN j = 36 THEN z.rec36
                                              WHEN j = 37 THEN z.rec37
                                              WHEN j = 38 THEN z.rec38
                                              WHEN j = 39 THEN z.rec39
                                              WHEN j = 40 THEN z.rec40
                                              WHEN j = 41 THEN z.rec41
                                              WHEN j = 42 THEN z.rec42
                                              WHEN j = 43 THEN z.rec43
                                              WHEN j = 44 THEN z.rec44
                                              WHEN j = 45 THEN z.rec45
                                              WHEN j = 46 THEN z.rec46
                                              WHEN j = 47 THEN z.rec47
                                              WHEN j = 48 THEN z.rec48
                                              WHEN j = 49 THEN z.rec49
                                              WHEN j = 50 THEN z.rec50
                                           END)
                                  END);
               END LOOP;
            END IF;

            EXIT WHEN v_count = v_html_rec;
         END LOOP;

         CLOSE x;

         UTL_SMTP.write_raw_data(v_conn
                                ,UTL_RAW.cast_to_raw(CONVERT(v_html
                                                            ,'ZHT16MSWIN950')));
         UTL_SMTP.write_data(v_conn
                            ,UTL_TCP.crlf
                             || UTL_TCP.crlf);
         v_html := v_html
                   || HTF.tableclose
                   || '<div style="font-family:Microsoft JhengHei;font-size:x-small;"> ' --寫入表頭
                   || v_prog
                   || '<br>'
                   || 'REQUEST ID：'
                   || TO_CHAR(v_request_id)
                   || '</div>'
                   || '</body></html>'
                   || UTL_TCP.crlf;
      END IF;


      IF NVL(p_excel_flag, 'Y') = 'Y'
      THEN --如果excel_flag 等於Y 及 v_temp_count大於v_html_rec ，則產生excel檔
         --IF v_temp_count > v_html_rec THEN
         v_attach_name := v_prog
                          || '_'
                          || v_db
                          || '_'
                          || TO_CHAR(SYSDATE
                                    ,'yymmddhh24miss')
                          || '.xls';

         v_filehandle := UTL_FILE.fopen(v_attach_path
                                       ,v_attach_name
                                       ,'W'
                                       ,32767);

         OPEN x FOR v_sql;

         LOOP
            FETCH x INTO z;

            EXIT WHEN x%NOTFOUND;

            v_header := CASE WHEN z.sort_order = 0 THEN 'No.' ELSE TO_CHAR(z.sort_order) END
                        || CHR(9)
                        || CASE WHEN v_column > 0 THEN z.rec1 END
                        || CASE
                              WHEN v_column > 1
                              THEN
                                 CHR(9)
                                 || z.rec2
                           END
                        || CASE
                              WHEN v_column > 2
                              THEN
                                 CHR(9)
                                 || z.rec3
                           END
                        || CASE
                              WHEN v_column > 3
                              THEN
                                 CHR(9)
                                 || z.rec4
                           END
                        || CASE
                              WHEN v_column > 4
                              THEN
                                 CHR(9)
                                 || z.rec5
                           END
                        || CASE
                              WHEN v_column > 5
                              THEN
                                 CHR(9)
                                 || z.rec6
                           END
                        || CASE
                              WHEN v_column > 6
                              THEN
                                 CHR(9)
                                 || z.rec7
                           END
                        || CASE
                              WHEN v_column > 7
                              THEN
                                 CHR(9)
                                 || z.rec8
                           END
                        || CASE
                              WHEN v_column > 8
                              THEN
                                 CHR(9)
                                 || z.rec9
                           END
                        || CASE
                              WHEN v_column > 9
                              THEN
                                 CHR(9)
                                 || z.rec10
                           END
                        || CASE
                              WHEN v_column > 10
                              THEN
                                 CHR(9)
                                 || z.rec11
                           END
                        || CASE
                              WHEN v_column > 11
                              THEN
                                 CHR(9)
                                 || z.rec12
                           END
                        || CASE
                              WHEN v_column > 12
                              THEN
                                 CHR(9)
                                 || z.rec13
                           END
                        || CASE
                              WHEN v_column > 13
                              THEN
                                 CHR(9)
                                 || z.rec14
                           END
                        || CASE
                              WHEN v_column > 14
                              THEN
                                 CHR(9)
                                 || z.rec15
                           END
                        || CASE
                              WHEN v_column > 15
                              THEN
                                 CHR(9)
                                 || z.rec16
                           END
                        || CASE
                              WHEN v_column > 16
                              THEN
                                 CHR(9)
                                 || z.rec17
                           END
                        || CASE
                              WHEN v_column > 17
                              THEN
                                 CHR(9)
                                 || z.rec18
                           END
                        || CASE
                              WHEN v_column > 18
                              THEN
                                 CHR(9)
                                 || z.rec19
                           END
                        || CASE
                              WHEN v_column > 19
                              THEN
                                 CHR(9)
                                 || z.rec20
                           END
                        || CASE
                              WHEN v_column > 20
                              THEN
                                 CHR(9)
                                 || z.rec21
                           END
                        || CASE
                              WHEN v_column > 21
                              THEN
                                 CHR(9)
                                 || z.rec22
                           END
                        || CASE
                              WHEN v_column > 22
                              THEN
                                 CHR(9)
                                 || z.rec23
                           END
                        || CASE
                              WHEN v_column > 23
                              THEN
                                 CHR(9)
                                 || z.rec24
                           END
                        || CASE
                              WHEN v_column > 24
                              THEN
                                 CHR(9)
                                 || z.rec25
                           END
                        || CASE
                              WHEN v_column > 25
                              THEN
                                 CHR(9)
                                 || z.rec26
                           END
                        || CASE
                              WHEN v_column > 26
                              THEN
                                 CHR(9)
                                 || z.rec27
                           END
                        || CASE
                              WHEN v_column > 27
                              THEN
                                 CHR(9)
                                 || z.rec28
                           END
                        || CASE
                              WHEN v_column > 28
                              THEN
                                 CHR(9)
                                 || z.rec29
                           END
                        || CASE
                              WHEN v_column > 29
                              THEN
                                 CHR(9)
                                 || z.rec30
                           END
                        || CASE
                              WHEN v_column > 30
                              THEN
                                 CHR(9)
                                 || z.rec31
                           END
                        || CASE
                              WHEN v_column > 31
                              THEN
                                 CHR(9)
                                 || z.rec32
                           END
                        || CASE
                              WHEN v_column > 32
                              THEN
                                 CHR(9)
                                 || z.rec33
                           END
                        || CASE
                              WHEN v_column > 33
                              THEN
                                 CHR(9)
                                 || z.rec34
                           END
                        || CASE
                              WHEN v_column > 34
                              THEN
                                 CHR(9)
                                 || z.rec35
                           END
                        || CASE
                              WHEN v_column > 35
                              THEN
                                 CHR(9)
                                 || z.rec36
                           END
                        || CASE
                              WHEN v_column > 36
                              THEN
                                 CHR(9)
                                 || z.rec37
                           END
                        || CASE
                              WHEN v_column > 37
                              THEN
                                 CHR(9)
                                 || z.rec38
                           END
                        || CASE
                              WHEN v_column > 38
                              THEN
                                 CHR(9)
                                 || z.rec39
                           END
                        || CASE
                              WHEN v_column > 39
                              THEN
                                 CHR(9)
                                 || z.rec40
                           END
                        || CASE
                              WHEN v_column > 40
                              THEN
                                 CHR(9)
                                 || z.rec41
                           END
                        || CASE
                              WHEN v_column > 41
                              THEN
                                 CHR(9)
                                 || z.rec42
                           END
                        || CASE
                              WHEN v_column > 42
                              THEN
                                 CHR(9)
                                 || z.rec43
                           END
                        || CASE
                              WHEN v_column > 43
                              THEN
                                 CHR(9)
                                 || z.rec44
                           END
                        || CASE
                              WHEN v_column > 44
                              THEN
                                 CHR(9)
                                 || z.rec45
                           END
                        || CASE
                              WHEN v_column > 45
                              THEN
                                 CHR(9)
                                 || z.rec46
                           END
                        || CASE
                              WHEN v_column > 46
                              THEN
                                 CHR(9)
                                 || z.rec47
                           END
                        || CASE
                              WHEN v_column > 47
                              THEN
                                 CHR(9)
                                 || z.rec48
                           END
                        || CASE
                              WHEN v_column > 48
                              THEN
                                 CHR(9)
                                 || z.rec49
                           END
                        || CASE
                              WHEN v_column > 49
                              THEN
                                 CHR(9)
                                 || z.rec50
                           END;

            UTL_FILE.put_line(v_filehandle
                             ,CONVERT(v_header
                                     ,'ZHT16BIG5'));

            EXIT WHEN z.sort_order =   v_init_count
                                     + 1;
         END LOOP;

         UTL_FILE.put_line(v_filehandle
                          ,CHR(0));
         UTL_FILE.fclose(v_filehandle);

         CLOSE x;
      --END IF;
      END IF;

      apps.send_mail(p_subject
                      ,v_html
                      ,p_rec_list
                      ,p_cc
                      ,v_attach_path
                      ,v_attach_name);

      UTL_SMTP.close_connection(v_conn);

     <<THE_END>>
      IF NVL(p_delete_flag, 'Y') = 'Y'
      THEN --如果DELETE_FLAG 等於 Y 則刪除XX_ALERT_TEMP該BATCH_ID 底下的資料
         BEGIN
            EXECUTE IMMEDIATE
               v_delete_sql
               || p_batch_id;

            COMMIT;
         EXCEPTION
            WHEN OTHERS
            THEN
               p_msg := 'PROCEDURE=>SEND_ALERT ERROR：'
                        || '刪除TEMP檔錯誤'
                        || SQLERRM;
               ROLLBACK;
               RAISE batch_null;
         END;
      END IF;


      BEGIN
         EXECUTE IMMEDIATE
            v_delete_history
            || p_batch_id
            || '-100';

         COMMIT;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            NULL;
         WHEN OTHERS
         THEN
            p_msg := 'PROCEDURE=>SEND_ALERT ERROR：'
                     || '刪除TEMP檔歷史資料錯誤'
                     || SQLERRM;
            ROLLBACK;
            RAISE batch_null;
      END;

      v_str := 'EXETIME:'
               || TO_CHAR(SYSDATE
                         ,'DD-MON-YY HH24:MI:SS')
               || CHR(10)
               || 'BATCHID:'
               || p_batch_id
               || ','
               || SQLERRM
               || CHR(10);

      --DBMS_OUTPUT.put_line (v_str);

      fnd_file.put_line(fnd_file.LOG
                       ,v_str);
   EXCEPTION
      WHEN batch_null
      THEN
         DBMS_OUTPUT.put_line(p_msg);
      WHEN OTHERS
      THEN
         p_msg := NVL(p_msg
                     ,'PROCEDURE=>SEND_ALERT ERROR !!'
                      || SQLERRM);
         --DBMS_OUTPUT.PUT_LINE (V_STR|| P_MSG);

         fnd_file.put_line(fnd_file.LOG
                          ,v_str
                           || p_msg);
   END send_alert;


   FUNCTION return_process_name
      RETURN VARCHAR2
   IS
      strowner VARCHAR2(32767);
      strname VARCHAR2(32767);
      nlineno NUMBER;
      strcaller_t VARCHAR2(32767);
      p_msg VARCHAR2(32767);
   BEGIN
      OWA_UTIL.who_called_me(strowner
                            ,strname
                            ,nlineno
                            ,strcaller_t);

      RETURN strname;
   EXCEPTION
      WHEN OTHERS
      THEN
         p_msg := NVL(p_msg, 'PROCEDURE=>RETURN_PROCESS_NAME ERROR !!');
   --DBMS_OUTPUT.PUT_LINE (P_MSG);
   END return_process_name;
END xx;


DECLARE
   p_sub VARCHAR2(20000);
   --郵件標題
   p_txt VARCHAR2(20000); --郵件正文
   p_receiver VARCHAR2(20000); --接收地址
   p_cc VARCHAR2(20000); --接收地址
   p_oracle_directory VARCHAR2(20000); --附檔路徑
   p_filename VARCHAR2(20000); --附件

   authid current_user;

   use_mathod VARCHAR2(20000) := '用system/manager 將下列權限給APPS 不然會沒辦法用
  GRANT CREATE ANY DIRECTORY TO APPS;
  GRANT GLOBAL QUERY REWRITE TO APPS;
  GRANT DROP ANY DIRECTORY TO APPS WITH ADMIN OPTION;
  --建立虛擬路徑
  CREATE OR REPLACE DIRECTORY DIR_FOR_SEND_MAIL1 AS ''/tmp''
  --給虛擬路徑給大家用
  GRANT READ,WRITE ON DIRECTORY DIR_FOR_SEND_MAIL1 TO PUBLIC;
  --查詢有無建立
  select * from dba_directories;
  --刪除建立的虛擬路徑
  drop directory DIR_FOR_SEND_MAIL1

  作用：用oracle發送郵件
  主要功能：1、支持多收件人
            2、支持中文
            3、支持抄送人
            4、支持大於32K的附件
            5、支持多行正文
            6、支持多附件
            7、支持文本附件和二進制附件
            8、支持HTML格式
  參數說明：
            p_txt :郵件正文
            p_sub: 郵件標題
            p_SendorAddress : 發送人郵件地址
            p_ReceiverAddress : 接收地址，可以同時發送到多個地址上，地址之間用","或者";"隔開
            p_EmailServer : 郵件服務器地址，可以是域名或者IP
            p_Port ：郵件服務器端口
            p_need_smtp：是否需要smtp認證，0表示不需要，1表示需要
            p_user：smtp驗證需要的用戶名
            p_pass：smtp驗證需要的密碼
            p_filename：附件名稱，必須包含完整的路徑，如"d:tempa.txt"。
                        可以有多個附件，附件名稱只能用逗號或者分號分隔
            p_encode：附件編碼轉換格式，其中 p_encode=''8bit'' 表示文本類型附件
                                             p_encode=''base64'' 表示二進制類型附件
  注意：
        1、對於文本類型的附件，不能用base64的方式發送，否則出錯
        2、對於多個附件只能用同一種格式發送';
   --固定參數
   p_sendor VARCHAR2(50) := 'XX@mail.com.tw';
   p_server VARCHAR2(30) := ''; --IP
   p_port NUMBER := 0; --port
   p_need_smtp INT := 1;
   p_user VARCHAR2(30) := 'RORY'; --account
   p_pass VARCHAR2(30) := '*****'; --password
   p_encode VARCHAR2(30) := '8bit'; --'base64';
   --以上為固定參數 ,說明請看上列參數說明

   l_crlf VARCHAR2(2) := UTL_TCP.crlf;
   l_sendoraddress VARCHAR2(4000);
   l_splite VARCHAR2(10) := '++';
   boundary CONSTANT VARCHAR2(256) := '-----BYSUK';
   first_boundary CONSTANT VARCHAR2(256)
      := '--'
         || boundary
         || l_crlf ;
   last_boundary CONSTANT VARCHAR2(256)
      := '--'
         || boundary
         || '--'
         || l_crlf ;
   multipart_mime_type CONSTANT VARCHAR2(256)
      := 'multipart/mixed; boundary="'
         || boundary
         || '"' ;
   /* 以下部分是發送大二進制附件時用到的變量 */
   l_fil BFILE;
   l_file_len NUMBER;
   l_modulo NUMBER;
   l_pieces NUMBER;
   l_file_handle UTL_FILE.file_type;
   l_amt BINARY_INTEGER
      :=   672
         * 3; /* ensures proper format;   2016 */
   l_filepos PLS_INTEGER := 1; /* pointer for the file */
   l_chunks NUMBER;
   l_buf RAW(2100);
   l_data RAW(2100);
   l_max_line_width NUMBER := 54;
   --L_DIRECTORY_BASE_NAME VARCHAR2(100) := 'DIR_FOR_SEND_MAIL'; --自定路徑
   l_line VARCHAR2(1000);
   l_mesg VARCHAR2(32767);

   /* 以上部分是發送大二進制附件時用到的變量 */

   TYPE address_list IS TABLE OF VARCHAR2(100)
      INDEX BY BINARY_INTEGER;

   my_address_list address_list;

   TYPE acct_list IS TABLE OF VARCHAR2(100)
      INDEX BY BINARY_INTEGER;

   my_acct_list acct_list;

   -------------------------------------返回附件源文件所在目錄或者名稱--------------------------------------
   FUNCTION get_file(p_file  VARCHAR2
                    ,p_get   INT)
      RETURN VARCHAR2
   IS
      --p_get=1 表示返回目錄
      --p_get=2 表示返回文件名
      l_file VARCHAR2(1000);
   BEGIN
      IF INSTR(p_file
              ,'\') > 0
      THEN
         --windows
         IF p_get = 1
         THEN
            l_file := SUBSTR(p_file
                            ,1
                            ,  INSTR(p_file
                                    ,'\'
                                    ,-1)
                             - 1);
         ELSIF p_get = 2
         THEN
            l_file := SUBSTR(p_file
                            ,-(  LENGTH(p_file)
                               - INSTR(p_file
                                      ,''
                                      ,-1)));
         END IF;
      ELSIF INSTR(p_file
                 ,'/') > 0
      THEN
         --linux/unix
         IF p_get = 1
         THEN
            l_file := SUBSTR(p_file
                            ,1
                            ,  INSTR(p_file
                                    ,'/'
                                    ,-1)
                             - 1);
         ELSIF p_get = 2
         THEN
            l_file := SUBSTR(p_file
                            ,-(  LENGTH(p_file)
                               - INSTR(p_file
                                      ,'/'
                                      ,-1)));
         END IF;
      END IF;

      RETURN l_file;
   END;

   ---------------------------------------------刪除directory------------------------------------
   PROCEDURE drop_directory(p_directory_name  VARCHAR2)
   IS
   BEGIN
      EXECUTE IMMEDIATE
         'drop directory '
         || p_directory_name;
   EXCEPTION
      WHEN OTHERS
      THEN
         NULL;
   END;

   --------------------------------------------------創建directory-----------------------------------------
   PROCEDURE create_directory(p_directory_name  VARCHAR2
                             ,p_dir             VARCHAR2)
   IS
   BEGIN
      EXECUTE IMMEDIATE
         'create or replace directory '
         || p_directory_name
         || ' as '''
         || p_dir
         || '''';

      EXECUTE IMMEDIATE
         'grant read,write on directory '
         || p_directory_name
         || ' to public';
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;

   --------------------------------------------分割郵件地址或者附件地址-----------------------------------
   PROCEDURE p_splite_str(p_str          VARCHAR2
                         ,p_splite_flag  INT DEFAULT 1)
   IS
      l_addr VARCHAR2(254) := '';
      l_len INT;
      l_str VARCHAR2(4000);
      j INT := 0; --表示郵件地址或者附件的個數
   BEGIN
      /*處理接收郵件地址列表，包括去空格、將;轉換為,等*/
      l_str := TRIM(RTRIM(REPLACE(REPLACE(p_str
                                         ,';'
                                         ,',')
                                 ,' '
                                 ,'')
                         ,','));
      l_len := LENGTH(l_str);

      FOR i IN 1 .. l_len
      LOOP
         IF SUBSTR(l_str
                  ,i
                  ,1) <> ','
         THEN
            l_addr := l_addr
                      || SUBSTR(l_str
                               ,i
                               ,1);
         ELSE
            j :=   j
                 + 1;

            IF p_splite_flag = 1
            THEN
               --表示處理郵件地址
               --前後需要加上'<>'，否則很多郵箱將不能發送郵件
               l_addr := '<'
                         || l_addr
                         || '>';
               --調用郵件發送過程
               my_address_list(j) := l_addr;
            ELSIF p_splite_flag = 2
            THEN
               --表示處理附件名稱
               my_acct_list(j) := l_addr;
            END IF;

            l_addr := '';
         END IF;

         IF i = l_len
         THEN
            j :=   j
                 + 1;

            IF p_splite_flag = 1
            THEN
               --調用郵件發送過程
               l_addr := '<'
                         || l_addr
                         || '>';
               my_address_list(j) := l_addr;
            ELSIF p_splite_flag = 2
            THEN
               my_acct_list(j) := l_addr;
            END IF;
         END IF;
      END LOOP;
   END;

   ------------------------------------------------寫郵件頭和郵件內容------------------------------------------
   PROCEDURE write_data(p_conn   IN OUT NOCOPY UTL_SMTP.connection
                       ,p_name                 VARCHAR2
                       ,p_value                VARCHAR2
                       ,p_splite               VARCHAR2 DEFAULT ':'
                       ,p_crlf                 VARCHAR2 DEFAULT l_crlf)
   IS
   BEGIN
      /* utl_raw.cast_to_raw 對解決中文亂碼問題很重要*/
      UTL_SMTP.write_raw_data(p_conn
                             ,UTL_RAW.cast_to_raw(CONVERT(p_name
                                                          || p_splite
                                                          || p_value
                                                          || p_crlf
                                                         ,'ZHT16BIG5')));
   --'UTF8' UTF8 'ZHT16BIG5' 繁體字 --'ZHS16GBK' 簡體
   END;

   ----------------------------------------寫MIME郵件尾部-----------------------------------------------------

   PROCEDURE end_boundary(conn IN OUT NOCOPY UTL_SMTP.connection
                         ,LAST IN            BOOLEAN DEFAULT FALSE)
   IS
   BEGIN
      UTL_SMTP.write_data(conn
                         ,UTL_TCP.crlf);

      IF (LAST)
      THEN
         UTL_SMTP.write_data(conn
                            ,last_boundary);
      END IF;
   END;

   ----------------------------------------------發送附件----------------------------------------------------
   PROCEDURE attachment(conn         IN OUT NOCOPY UTL_SMTP.connection
                       ,mime_type                  VARCHAR2 DEFAULT 'text/html'
                       ,inline                     BOOLEAN DEFAULT TRUE
                       ,filename                   VARCHAR2 DEFAULT 't.txt'
                       ,transfer_enc               VARCHAR2 DEFAULT '8bit'
                       ,dt_name                    VARCHAR2 DEFAULT '0')
   IS
      l_filename VARCHAR2(1000);
   BEGIN
      --寫附件頭
      UTL_SMTP.write_data(conn
                         ,first_boundary);
      --設置附件格式
      l_filename := filename;

      IF (inline)
      THEN
         write_data(conn
                   ,'Content-Disposition'
                   ,'inline; filename="'
                    || l_filename
                    || '"');
      ELSE
         write_data(conn
                   ,'Content-Disposition'
                   ,'attachment; filename="'
                    || l_filename
                    || '"');
      END IF;

      --設置附件的轉換格式
      IF (transfer_enc IS NOT NULL)
      THEN
         write_data(conn
                   ,'Content-Transfer-Encoding'
                   ,transfer_enc);
      END IF;

      UTL_SMTP.write_data(conn
                         ,UTL_TCP.crlf);

      --begin 貼附件內容
      IF transfer_enc = '8bit'
      THEN
         --如果是文本類型的附件
         BEGIN
            l_file_handle := UTL_FILE.fopen(dt_name
                                           ,l_filename
                                           ,'r'); --打開文件

            --把附件分成多份，這樣可以發送超過32K的附件
            LOOP
               UTL_FILE.get_line(l_file_handle
                                ,l_line);
               l_mesg := l_line
                         || l_crlf;
               write_data(conn
                         ,''
                         ,l_mesg
                         ,''
                         ,'');
            END LOOP;

            UTL_FILE.fclose(l_file_handle);
            end_boundary(conn);
         EXCEPTION
            WHEN OTHERS
            THEN
               UTL_FILE.fclose(l_file_handle);
               end_boundary(conn);
         END; --結束文本類型附件的處理
      ELSIF transfer_enc = 'base64'
      THEN
         --如果是二進制類型的附件
         BEGIN
            --把附件分成多份，這樣可以發送超過32K的附件
            l_filepos := 1; --重置offset，在發送多個附件時，必須重置
            l_fil := BFILENAME(dt_name
                              ,l_filename);
            l_file_len := DBMS_LOB.getlength(l_fil); --取得檔案長度
            l_modulo := MOD(l_file_len
                           ,l_amt); --檔案長度/L_AMT 的餘數
            l_pieces := TRUNC(  l_file_len
                              / l_amt); --檔案長度/L_AMT 的商數

            --如有餘數則多加 1
            IF (l_modulo <> 0)
            THEN
               l_pieces :=   l_pieces
                           + 1;
            END IF;

            DBMS_LOB.fileopen(l_fil
                             ,DBMS_LOB.file_readonly); --開檔
            DBMS_LOB.read(l_fil
                         ,l_amt
                         ,l_filepos
                         ,l_buf); --讀出檔案
            l_data := NULL;

            FOR i IN 1 .. l_pieces
            LOOP
               l_filepos :=     i
                              * l_amt
                            + 1;
               l_file_len :=   l_file_len
                             - l_amt;
               l_data := UTL_RAW.CONCAT(l_data
                                       ,l_buf);
               l_chunks := TRUNC(  UTL_RAW.LENGTH(l_data)
                                 / l_max_line_width);

               IF (i <> l_pieces)
               THEN
                  l_chunks :=   l_chunks
                              - 1;
               END IF;

               UTL_SMTP.write_raw_data(conn
                                      ,UTL_ENCODE.base64_encode(l_data));
               l_data := NULL;

               IF (l_file_len < l_amt
                   AND l_file_len > 0)
               THEN
                  l_amt := l_file_len;
               END IF;

               --資料已經結束
               IF l_file_len <> 0
               THEN
                  DBMS_LOB.read(l_fil
                               ,l_amt
                               ,l_filepos
                               ,l_buf);
               END IF;
            END LOOP;

            DBMS_LOB.fileclose(l_fil);
            end_boundary(conn);
         EXCEPTION
            WHEN OTHERS
            THEN
               IF DBMS_LOB.ISOPEN(l_fil) = 1
               THEN
                  DBMS_LOB.fileclose(l_fil);
               END IF;

               end_boundary(conn);
               RAISE;
         END; --結束處理二進制附件
      END IF; --結束處理附件內容
   END;

   ---------------------------------------------真正發送郵件的過程--------------------------------------------
   PROCEDURE p_email(p_sendoraddress2    VARCHAR2
                    , --發送地址
                     p_receiveraddress2  VARCHAR2) --接受地址
   IS
      l_conn UTL_SMTP.connection; --定義連接
      l_db_name VARCHAR2(200) := fnd_profile.VALUE('APPS_DATABASE_ID');
      v_datetime VARCHAR2(20)
         := TO_CHAR(SYSDATE
                   ,'YYYY/MM/DD HH24:MI:SS');
   BEGIN
      /*初始化郵件服務器信息，連接郵件服務器*/
      l_conn := UTL_SMTP.open_connection(p_server
                                        ,p_port);
      --UTL_SMTP.HELO(L_CONN ,P_SERVER); --有些要用此指令才會送
      UTL_SMTP.ehlo(l_conn
                   ,p_server); --大部份用此指令送

      /* smtp服務器登錄校驗 */
      IF p_need_smtp = 1
      THEN
         UTL_SMTP.command(l_conn
                         ,'AUTH LOGIN'
                         ,'');
         UTL_SMTP.command(l_conn
                         ,UTL_RAW.cast_to_varchar2(UTL_ENCODE.base64_encode(UTL_RAW.cast_to_raw(p_user))));
         UTL_SMTP.command(l_conn
                         ,UTL_RAW.cast_to_varchar2(UTL_ENCODE.base64_encode(UTL_RAW.cast_to_raw(p_pass))));
      END IF;

      /*設置發送地址和接收地址*/
      UTL_SMTP.mail(l_conn
                   ,p_sendoraddress2);
      UTL_SMTP.rcpt(l_conn
                   ,p_receiveraddress2);

      /*設置郵件頭*/
      UTL_SMTP.open_data(l_conn);
      /*設置發送時間*/
      write_data(l_conn
                ,'Date'
                ,v_datetime);
      /*設置發送人*/
      write_data(l_conn
                ,'From'
                ,p_sendor);
      /*設置接收人*/
      write_data(l_conn
                ,'To'
                ,p_receiver);
      /*設置CC接收人*/
      write_data(l_conn
                ,'cc'
                ,p_cc);
      /*設置郵件主題*/
      write_data(l_conn
                ,'Subject'
                ,p_sub
                 || '('
                 || l_db_name
                 || ')');
      write_data(l_conn
                ,'Content-Type'
                ,multipart_mime_type);
      UTL_SMTP.write_data(l_conn
                         ,UTL_TCP.crlf);
      UTL_SMTP.write_data(l_conn
                         ,first_boundary);
      --WRITE_DATA(L_CONN ,'Content-Type' ,'text/plain;charset=gb2312'); --GB2312 為簡體
      write_data(l_conn
                ,'Content-Type'
                ,'text/html;charset=BIG5'); --指定寄出的內容為BIG5
      --單獨空一行，否則，正文內容不顯示
      UTL_SMTP.write_data(l_conn
                         ,UTL_TCP.crlf);
      /* 設置郵件正文
       把分隔符還原成chr(10)。這主要是為了shell中調用該過程，如果有多行，則先把多行的內容合併成一行，並用 l_splite分隔
       然後用 l_crlf替換chr(10)。這一步是必須的，否則將不能發送郵件正文有多行的郵件*/
      write_data(l_conn
                ,''
                ,REPLACE(REPLACE(p_txt
                                ,l_splite
                                ,CHR(10))
                        ,CHR(10)
                        ,l_crlf)
                ,''
                ,'');
      end_boundary(l_conn);

      --如果文件名稱不為空，則發送附件
      IF (p_filename IS NOT NULL)
      THEN
         --根據逗號或者分號拆分附件地址
         p_splite_str(p_filename
                     ,2);

         --循環發送附件(在同一個郵件中)
         FOR k IN 1 .. my_acct_list.COUNT
         LOOP
            attachment(conn => l_conn
                      ,filename => my_acct_list(k)
                      ,transfer_enc => p_encode
                      ,dt_name => p_oracle_directory);
         END LOOP;
      END IF;

      /*關閉數據寫入*/
      UTL_SMTP.close_data(l_conn);
      /*關閉連接*/
      UTL_SMTP.quit(l_conn);
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;
---------------------------------------------------主過程-----------------------------------------------------
BEGIN
   l_sendoraddress := '<'
                      || p_sendor
                      || '>';
   p_splite_str(p_receiver); --處理郵件地址

   FOR k IN 1 .. my_address_list.COUNT
   LOOP
      p_email(l_sendoraddress
             ,my_address_list(k));
   END LOOP;

   IF p_cc IS NOT NULL
   THEN
      p_splite_str(p_cc);

      FOR k IN 1 .. my_address_list.COUNT
      LOOP
         p_email(l_sendoraddress
                ,my_address_list(k));
      END LOOP;
   END IF; --處理郵件地址
/*處理郵件地址，根據逗號分割郵件*/

EXCEPTION
   WHEN OTHERS
   THEN
      fnd_file.put_line(fnd_file.LOG
                       ,'Error:'
                        || SQLERRM);
      --DBMS_OUTPUT.put_line(DBMS_UTILITY.format_error_stack);
      --DBMS_OUTPUT.put_line(DBMS_UTILITY.format_call_stack);
      RAISE;
END;
